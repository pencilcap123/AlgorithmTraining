# 序列型
## 特征
1. 给定一个序列
2. 动态规划方程f[i]中的下标i表示前i个元素a[0],a[1],...,a[i-1]的某种性质
3. 初始化时，f[0]表示空序列的性质


## 房屋染色1
序列+状态，当每个dp位置都可能有可穷举的几种状态得出时，可以用此解法
### 描述
这里有n个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小，返回最小的费用。
费用通过一个nx3 的矩阵给出，比如cost[0][0]表示房屋0染红色的费用，cost[1][2]表示房屋1染绿色的费用，依此类推。找到油漆所有房子的最低成本。
所有费用都是正整数

样例 1:
输入: [[14,2,11],[11,14,5],[14,3,10]]
输出: 10
解释: 第一个屋子染蓝色，第二个染绿色，第三个染蓝色，最小花费：2 + 5 + 3 = 10.

样例 2:
输入: [[1,2,3],[1,4,6]]
输出: 3

### 解答
```java
public class Solution {
    /**
     * @param costs: n x 3 cost matrix
     * @return: An integer, the minimum cost to paint all houses
     */
    public int minCost(int[][] costs) {
        // write your code here
        // f[i][0] = min(f[i-1][1] + costs[i][0], f[i-1][2] + costs[i][0])
        // f[i][1] = min(f[i-1][0] + costs[i][1], f[i-1][2] + costs[i][1])
        // f[i][2] = min(f[i-1][0] + costs[i][2], f[i-1][1] + costs[i][2])
        // Result = min(f[i][0], f[i][1], f[i][2])
        
        int houses = costs.length;
        if (houses == 0) {
            return 0;
        }

        int colors = 3;

        int[][] dp = new int[houses][colors];

        dp[0][0] = costs[0][0];
        dp[0][1] = costs[0][1];
        dp[0][2] = costs[0][2];

        for (int i = 1; i < houses; i++) {
            dp[i][0] = Math.min(dp[i-1][1], dp[i-1][2]) + costs[i][0];
            dp[i][1] = Math.min(dp[i-1][0], dp[i-1][2]) + costs[i][1];
            dp[i][2] = Math.min(dp[i-1][0], dp[i-1][1]) + costs[i][2];
        }

        return Math.min(Math.min(dp[houses-1][0], dp[houses-1][1]), dp[houses-1][2]);
    }
}
```

## 最长单调子序列
### 描述
给定a[0],...,a[n-1]，找到最长连续子序列i,i+1,i+2,...,j,   使得a[i]<a[i+1]<..<a[j]，或者a[i]>a[i+1]>..>a[j]，输出长度j-1+1，

例子：输入[5,1,2,3,4]，输出：4（对应子序列1,2,3,4）

### 解答
```java
public class Solution {

    public int findMaxMonotonicSequence(int[] nums) {
        // f(i) = max(1, (f(i-1) + 1) && (a[i-1] < a[i]))

        // find longest monotonic sequence in original direction
        int lengthOfOriginDirection = doFindMaxMonotonicSequence(nums);

        // reverse nums
        for (int idx = 0; idx < nums.length / 2; idx++) {
            int tmp = nums[nums.length - 1 - idx];
            nums[nums.length - 1 - idx] = nums[idx];
            nums[idx] = tmp;
        }

        // find longest monotonic sequence in reverse direction
        int lengthOfReverseDirection = doFindMaxMonotonicSequence(nums);

        return Math.max(lengthOfOriginDirection, lengthOfReverseDirection);
    }

    public int doFindMaxMonotonicSequence(int[] nums) {
        int[] dp = new int[nums.length + 1];

        dp[0] = 1;

        for (int idx = 1; idx < nums.length; idx++) {
            dp[idx] = Math.max(1, (nums[idx - 1] < nums[idx]) ? dp[idx - 1] + 1 : 0);
        }

        return dp[nums.length - 1];
    }

    public static void main(String[] args) {
        int[] nums = new int[]{5, 4, 3, 2, 1, 0, 1, 6, 3, 4};

        System.out.println(new Solution().findMaxMonotonicSequence(nums));
    }
}
```

## 房屋染色2
### 描述
这里有n个房子在一列直线上，现在我们需要给房屋染色，共有k种颜色。每个房屋染不同的颜色费用也不同，你希望每两个相邻的房屋颜色不同费用通过一个nxk 的矩阵给出，比如cost[0][0]表示房屋0染颜色0的费用,cost[1][2]表示房屋1染颜色2的费用。找到油漆所有房子的最低成本。(所有费用都是正整数)

样例

样例1

输入:
costs = [[14,2,11],[11,14,5],[14,3,10]]
输出: 10
说明:
三个屋子分别使用第1,2,1种颜色，总花费是10。

样例2

输入:
costs = [[5]]
输出: 5
说明：
只有一种颜色，一个房子，花费为5

### 解答
```java
package com.xz.quiz.lintcode.dp.painthouse2;

public class Solution {
    public int minimumCost(int[][] costs) {
        if (costs.length == 0 || costs[0].length == 0) {
            return 0;
        }

        int houses = costs.length;
        int colors = costs[0].length;

        /**
         * f[i][j] = min {
         *     f[i-1][0],
         *     f[i-1][1],
         *     ...
         *     f[i-1][j-1]
         *     f[i-1][j-2]
         *     ...
         *     f[i-1][k]
         * } + cost[i-1][j]
         */

        int[][] dp = new int[houses + 1][colors];
        for (int houseIdx = 1; houseIdx <= houses; houseIdx++) {
            // O(M^2)
//            for (int colorIdx = 0; colorIdx < colors; colorIdx++) {
//                int minCost = Integer.MAX_VALUE;
//                for (int i = 0; i < colors; i++) {
//                    if (colorIdx == i) {
//                        continue;
//                    }
//                    minCost = Math.min(dp[houseIdx - 1][i], minCost);
//                }
//
//                dp[houseIdx][colorIdx] = (minCost == Integer.MAX_VALUE ? 0 : minCost) + costs[houseIdx - 1][colorIdx];
//            }

            // O(M)
            // given a[0]~a[n], a[i]=min(a[0], .., a[n]), a[j]=secondMin(a[0], .., a[n])
            // let's say we remove a[k], 0<=k<=n
            // if k != i, min(a[0],..,a[k-1],a[k],.. a[n]) is still a[i]
            // if k = i,  min(a[0],..,a[k-1],a[k],.. a[n]) still a[j]
            int minIdx = -1;
            int min = Integer.MAX_VALUE;
            int lastMinIdx = -1;
            int lastMin = Integer.MAX_VALUE;
            for (int colorIdx = 0; colorIdx < colors; colorIdx++) {
                if (dp[houseIdx - 1][colorIdx] < min) {
                    lastMin = min;
                    lastMinIdx = minIdx;
                    min = dp[houseIdx - 1][colorIdx];
                    minIdx = colorIdx;
                } else if (dp[houseIdx - 1][colorIdx] < lastMin) {
                    lastMin = dp[houseIdx - 1][colorIdx];
                    lastMinIdx = colorIdx;
                }
            }

            if (lastMinIdx == -1) {
                lastMinIdx = minIdx;
            }

            for (int colorIdx = 0; colorIdx < colors; colorIdx++) {
                if (colorIdx == minIdx) {
                    dp[houseIdx][colorIdx] = dp[houseIdx - 1][lastMinIdx] + costs[houseIdx - 1][colorIdx];
                } else {
                    dp[houseIdx][colorIdx] = dp[houseIdx - 1][minIdx] + costs[houseIdx - 1][colorIdx];
                }
            }
        }

        int minCost = Integer.MAX_VALUE;
        for (int colorIdx = 0; colorIdx < colors; colorIdx++) {
            minCost = Math.min(dp[houses][colorIdx], minCost);
        }

        return minCost;
    }

    public static void main(String[] args) {
        int[][] costs = new int[][]{
                {
                        5
                }
        };
        System.out.println(new Solution().minimumCost(costs));
    }
}

```

## 搜刮房子
### 描述
假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。
给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，在不触动报警装置的情况下, 你最多可以得到多少钱 。

样例

样例 1:

输入: [3, 8, 4]
输出: 8
解释: 仅仅打劫第二个房子.

样例 2:

输入: [5, 2, 1, 3] 
输出: 8
解释: 抢第一个和最后一个房子

### 解答
```java
public class Solution {
    public long houseRobber(int[] A) {
        // f[i] = max(
        //      f[i-2] + a[i-1],
        //      f[i-1]
        // )
        if (A == null || A.length == 0) {
            return 0;
        }

        int houses = A.length;
        if (houses == 1) {
            return A[0];
        }

        long[] dp = new long[houses + 1];
        dp[0] = 0;
        dp[1] = A[0];

        for (int i = 2; i <= houses; i++) {
            dp[i] = Math.max(dp[i - 2] + A[i - 1], dp[i - 1]);
        }

        return dp[houses];
    }


    public static void main(String[] args) {
        int[] houses = new int[]{5, 2, 1, 3};

        System.out.println(new Solution().houseRobber(houses));
    }
}
```

## 双序列：最长公共子序列
### 描述
给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。

样例

样例 1:

	输入:  "ABCD" and "EDCA"
	输出:  1
	
	解释:
	LCS 是 'A' 或  'D' 或 'C'


样例 2:

	输入: "ABCD" and "EACB"
	输出:  2
	
	解释: 
	LCS 是 "AC"
### 解答
```java
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    public int longestCommonSubsequence(String AA, String BB) {
        if (AA == null || AA.length() == 0 || BB == null || BB.length() == 0) {
            return 0;
        }

        char[] aa = AA.toCharArray();
        char[] bb = BB.toCharArray();

        int lenA = AA.length();
        int lenB = BB.length();

        int[][] dp = new int[lenA + 1][lenB + 1];
        int[][] decisions = new int[lenA + 1][lenB + 1]; // used to recover the longest common subsequence

        // f[i][j] = max(f[i-1][j], f[i][j-1], f[i-1][j-1] + 1 when a[i-1] == b[j-1])
        for (int i = 0; i <= lenA; i++) {
            for (int j = 0; j <= lenB; j++) {
                if (i == 0 || j == 0) {
                    // subsequence between an empty string and a non-empty string is always 0 in length
                    dp[i][j] = 0;
                    continue;
                }

                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);

                // record decision
                if (dp[i][j] == dp[i - 1][j]) {
                    decisions[i][j] = 1;
                } else {
                    decisions[i][j] = 2;
                }

                if (aa[i - 1] == bb[j - 1]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);

                    // record decision
                    if (dp[i][j] == dp[i - 1][j - 1] + 1) {
                        decisions[i][j] = 3;
                    }
                }
            }
        }

        // recover lcs
        char[] result = new char[dp[lenA][lenB]];
        int p = dp[lenA][lenB] - 1;
        int i = lenA;
        int j = lenB;
        while (i > 0 && j > 0) {
            if (decisions[i][j] == 1) {
                i--;
            } else if (decisions[i][j] == 2) {
                j--;
            } else {
                result[p--] = aa[i - 1];
                i--;
                j--;
            }
        }

        System.out.println(String.valueOf(result));
        return dp[lenA][lenB];
    }

```

## 双序列：交叉字符串
### 描述
描述
给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。

样例

样例 1：

输入：

s1 = "aabcc"
s2 = "dbbca"
s3 = "aadbbcbcac"
输出：

true
解释：

s3 可以由 s1 与 s2 交叉构成。

样例 2：

输入：

s1 = ""
s2 = ""
s3 = "1"
输出：

false
解释：

s3 不可以由 s1 与 s2 交叉构成。

样例 3：

输入：

s1 = "aabcc"
s2 = "dbbca"
s3 = "aadbbbaccc"
输出：

false
解释：

s3 不可以由 s1 与 s2 交叉构成。
### 解答
```java
    public boolean isInterleave(String ss1, String ss2, String ss3) {
        int len1 = ss1.length();
        int len2 = ss2.length();
        int len3 = ss3.length();

        if (len1 + len2 != len3) {
            return false;
        }

        char[] cc1 = ss1.toCharArray();
        char[] cc2 = ss2.toCharArray();
        char[] cc3 = ss3.toCharArray();

        boolean[][] dp = new boolean[len1 + 1][len2 + 1];
        for (int i = 0; i <= len1; i++) {
            for (int j = 0; j <= len2; j++) {
                if (i == 0 && j == 0) {
                    // two empty string can form a new empty string
                    dp[i][j] = true;
                    continue;
                }

                // f[i][j] = f[i-1][j] when A[i-1] == S[i+j-1]    or    f[i][j-1] when B[j-1] when S[i+j-1]
                if (i > 0 && cc1[i - 1] == cc3[i + j - 1]) {
                    dp[i][j] |= dp[i - 1][j];
                }

                if (j > 0 && cc2[j - 1] == cc3[i + j - 1]) {
                    dp[i][j] |= dp[i][j - 1];
                }
            }
        }

        return dp[len1][len2];
    }
```

## 双序列：字符串编辑距离
### 描述
给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。

你可进行三种操作：

插入一个字符
删除一个字符
替换一个字符

样例

样例 1:

输入: 
"horse"
"ros"
输出: 3

解释: 
horse -> rorse (替换 'h' 为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

样例 2:

输入: 
"intention"
"execution"
输出: 5

解释: 
intention -> inention (删除 't')
inention -> enention (替换 'i' 为 'e')
enention -> exention (替换 'n' 为 'x')
exention -> exection (替换 'n' 为 'c')
exection -> execution (插入 'u')
### 解答
状态转移方程：
```
f[i][j] = min {
   	when i > 0 && j > 0:
		f[i-1][j-1],            if A[i-1] == B[j-1], do nothing
		f[i-1][j-1] + 1， 	replace A[i-1] with B[j-1]
		f[i-1][j] + 1,           remove A[i-1]
		f[i][j-1] + 1,           append B[j-1] after A[i-1]
	when i == 0 && j > 0:
		f[i][j-1] + 1,           append B[j-1] after A[i-1]
	when i > 0 && j == 0:
		f[i-1][j] + 1,           remove A[i-1]
	when i == 0 && j == 0:
		0
   }
```
```java
    public int minSteps(String s1, String s2) {
        char[] cc1 = s1.toCharArray();
        char[] cc2 = s2.toCharArray();

        int len1 = cc1.length;
        int len2 = cc2.length;

        int[][] dp = new int[len1 + 1][len2 + 1];

        for (int i = 0; i <= len1; ++i) {
            for (int j = 0; j <= len2; ++j) {
                if (i == 0 && j == 0) {
                    dp[i][j] = 0;
                    continue;
                }

                if (i > 0 && j > 0) {
                    if (cc1[i - 1] != cc2[j - 1]) {
                        // replace s1[i-1] with s2[j-1]
                        dp[i][j] = dp[i - 1][j - 1] + 1;

                        // remove s1[i-1]
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);

                        // append s2[j-1] after s[i-1]
                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);
                    } else {
                        // do nothing
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else if (i == 0) {
                    // append s2[j-1] after s[i-1]
                    dp[i][j] = dp[i][j - 1] + 1;
                } else if (j == 0) {
                    // remove s1[i-1]
                    dp[i][j] = dp[i - 1][j] + 1;
                }
            }
        }

        return dp[len1][len2];
    }

```

## 字符串最大出现次数
### 描述
给定字符串 S 和 T, 字符串S中有多少个子序列字符串和字符串T相同。

子序列字符串是原始字符串删除一些(或零个)字符之后得到的字符串, 并且不能改变剩下字符的相对位置。(比如 "ACE" 是 ABCDE 的一个子序列, 而 "AEC" 不是)

样例

样例 1:

输入: S = "rabbbit", T = "rabbit"
输出: 3
解释: 你可以删除 S 中的任意一个 'b', 所以一共有 3 种方式得到 T.

样例 2:

输入: S = "abcd", T = ""
输出: 1
解释: 只有删除 S 中的所有字符这一种方式得到 T
### 解答
```java
    public int maxAppearTimes(String A, String B) {
        /**
         * f[i][j] = f[i-1][j] + (f[i-1][j-1] if A[i-1] == B[j-1])
         */
        if (B == null || B.length() == 0) {
            return 0;
        }

        int l1 = A.length();
        int l2 = B.length();

        char[] cc1 = A.toCharArray();
        char[] cc2 = B.toCharArray();

        int[][] dp = new int[l1 + 1][l2 + 1];
        for (int i = 0; i <= l1; i++) {
            for (int j = 0; j <= l2; j++) {
                if (j == 0) {
                    // init :
                    // f[0][0] = 1
                    // f[i][0] = 1
                    dp[i][j] = 1;
                    continue;
                }

                if (i == 0) {
                    // init :
                    // f[0][j] = 1
                    dp[i][j] = 0;
                    continue;
                }

                dp[i][j] = dp[i - 1][j];
                if (cc1[i - 1] == cc2[j - 1]) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }

        return dp[l1][l2];
    }
```

## 正则匹配
### 描述
实现支持'.'和'*'的正则表达式匹配。

'.'匹配任意一个字母。

'*'匹配零个或者多个前面的元素。

匹配应该覆盖整个输入字符串，而不仅仅是一部分。

需要实现的函数是：bool isMatch(string s, string p)

isMatch("aa","a") → false

isMatch("aa","aa") → true

isMatch("aaa","aa") → false

isMatch("aa", "a*") → true

isMatch("aa", ".*") → true

isMatch("ab", ".*") → true

isMatch("aab", "c*a*b") → true
### 解答
```java
    public boolean isMatch(String A, String B) {
        int len1 = A.length();
        int len2 = B.length();

        char[] aa = A.toCharArray();
        char[] bb = B.toCharArray();

        boolean[][] dp = new boolean[len1 + 1][len2 + 1];

        for (int i = 0; i <= len1; i++) {
            for (int j = 0; j <= len2; j++) {
                if (j == 0) {
                    // init
                    // A ''  B ''
                    dp[i][j] = i == 0;
                    continue;
                }

                // f[i][j] = {
                //      f[i-1][j-1]                                                         if A[i-1] == B[j-1] or B[j-1] == '.'
                //      f[i][j-2] or (f[i-1][j] if (B[j-2] == '.' or B[j-2] == A[i-1]))     if B[j-1] == '*'
                // }
                if (bb[j - 1] != '*') {
                    if (i >= 1 && (aa[i - 1] == bb[j - 1] || bb[j - 1] == '.')) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    if (j >= 2) {
                        dp[i][j] = dp[i][j - 2];
                    }

                    if (i >= 1 && j >= 2) {
                        if (bb[j - 2] == '.' || bb[j - 2] == aa[i - 1]) {
                            dp[i][j] |= dp[i - 1][j];
                        }
                    }
                }
            }
        }

        return dp[len1][len2];
    }
```

## 通配符
### 描述
    public boolean isMatch(String A, String B) {
        int len1 = A.length();
        int len2 = B.length();

        char[] aa = A.toCharArray();
        char[] bb = B.toCharArray();

        boolean[][] dp = new boolean[len1 + 1][len2 + 1];

        for (int i = 0; i <= len1; i++) {
            for (int j = 0; j <= len2; j++) {
                if (i == 0 && j == 0) {
                    // init
                    // A ''  B '' 空字符匹配
                    dp[i][j] = true;
                    continue;
                }

                if (j == 0) {
                    // init
                    // A '任何字符'  B '' 都不匹配
                    dp[i][j] = false;
                    continue;
                }

                // f[i][j] = {
                //      f[i-1][j-1]                               if A[i-1] == B[j-1] or B[j-1] == '?'
                //      f[i][j-1] or (f[i-1][j])                  if B[j-1] == '*'
                // }

                if (i >= 1) {
                    if (bb[j - 1] != '*') {
                        if (aa[i - 1] == bb[j - 1] || bb[j - 1] == '?') {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    } else {
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                    }
                } else {
                    dp[i][j] = j == 1 && bb[j - 1] == '*';
                }
            }
        }

        return dp[len1][len2];
    }

### 解答
```java
    public boolean isMatch(String A, String B) {
        int len1 = A.length();
        int len2 = B.length();

        char[] aa = A.toCharArray();
        char[] bb = B.toCharArray();

        boolean[][] dp = new boolean[len1 + 1][len2 + 1];

        for (int i = 0; i <= len1; i++) {
            for (int j = 0; j <= len2; j++) {
                if (i == 0 && j == 0) {
                    // init
                    // A ''  B '' 空字符匹配
                    dp[i][j] = true;
                    continue;
                }

                if (j == 0) {
                    // init
                    // A '任何字符'  B '' 都不匹配
                    dp[i][j] = false;
                    continue;
                }

                // f[i][j] = {
                //      f[i-1][j-1]                               if A[i-1] == B[j-1] or B[j-1] == '?'
                //      f[i][j-1] or (f[i-1][j])                  if B[j-1] == '*'
                // }

                if (i >= 1) {
                    if (bb[j - 1] != '*') {
                        if (aa[i - 1] == bb[j - 1] || bb[j - 1] == '?') {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    } else {
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                    }
                } else {
                    dp[i][j] = j == 1 && bb[j - 1] == '*';
                }
            }
        }

        return dp[len1][len2];
    }
```

### 进一步思考
如果房子是成圈而不是一排排列的，那么a[0]与a[n-1]成为邻居，不能同时偷，则需要计算两种情况
1. 0不偷，则计算a[1]..a[n-1]的最优策略
2. n-1不偷，则计算a[0]...a[n-2]的最优策略

取上述最大值即可
